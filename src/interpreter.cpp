#include "interpreter.h"

namespace nabla {

namespace {

class Value
{
public:
  virtual ~Value() = default;

  virtual void print(Runtime& runtime) const = 0;
};

template<typename T>
class ValueImpl final : public Value
{
  T value_;

public:
  explicit ValueImpl(T value)
    : value_(value)
  {
  }

  [[nodiscard]] auto value() const -> const T& { return value_; }

  void print(Runtime& runtime) const override { runtime.print(value_); }
};

using IntValue = ValueImpl<int>;

using FloatValue = ValueImpl<float>;

using StringValue = ValueImpl<std::string>;

using ValuePtr = std::unique_ptr<Value>;

struct Context final
{
  Runtime* runtime;

  std::vector<ValuePtr> values;

  /// @brief This is the ID of the value generated by the last expression.
  ///        A lot of the time, it is the last generated value in the list.
  ///        Sometimes, when a variable is references, this member will be
  ///        assigned to the value being referenced (which may not be the
  ///        last value in the list).
  size_t last_value_index{ 0 };
};

class InterpreterImpl final
  : public Interpreter
  , public ast::StmtVisitor
  , public ast::ExprVisitor
{
  Context context_;

public:
  explicit InterpreterImpl(Runtime* runtime)
    : context_{ runtime }
  {
  }

  void exec(const ast::Module& mod) override
  {
    for (const auto& stmt : mod.stmts) {
      stmt->accept(*this);
    }
  }

protected:
  void visit(const ast::AssignStmt& stmt) override
  {
    // since we build the value table the same way the expressions are layed out in the AST, we do not need to map them
    // to the IDs.
    stmt.value().accept(*this);
  }

  void visit(const ast::PrintStmt& stmt) override
  {
    const auto id = stmt.id();
    context_.values.at(id)->print(*context_.runtime);
  }

  void visit(const ast::PrintEndStmt&) override { context_.runtime->print_end(); }

  void visit(const ast::LiteralExpr<int>& expr) override
  {
    context_.values.emplace_back(std::make_unique<IntValue>(expr.value()));
  }

  void visit(const ast::LiteralExpr<float>& expr) override
  {
    context_.values.emplace_back(std::make_unique<FloatValue>(expr.value()));
  }

  void visit(const ast::LiteralExpr<std::string>& expr) override
  {
    context_.values.emplace_back(std::make_unique<StringValue>(expr.value()));
  }

  void visit(const ast::AddExpr<int>& expr) override
  {
    const auto* l = static_cast<const IntValue*>(context_.values.at(expr.left()).get());
    const auto* r = static_cast<const IntValue*>(context_.values.at(expr.right()).get());
    push_value(std::make_unique<IntValue>(l->value() + r->value()));
  }

  void visit(const ast::AddExpr<float>& expr) override
  {
    const auto* l = static_cast<const FloatValue*>(context_.values.at(expr.left()).get());
    const auto* r = static_cast<const FloatValue*>(context_.values.at(expr.right()).get());
    push_value(std::make_unique<FloatValue>(l->value() + r->value()));
  }

  void visit(const ast::AddExpr<std::string>&) override {}

  void visit(const ast::MulExpr<int, int>& expr) override
  {
    const auto* l = static_cast<const IntValue*>(context_.values.at(expr.left()).get());
    const auto* r = static_cast<const IntValue*>(context_.values.at(expr.right()).get());
    push_value(std::make_unique<IntValue>(l->value() * r->value()));
  }

  void visit(const ast::MulExpr<float, float>& expr) override
  {
    const auto* l = static_cast<const FloatValue*>(context_.values.at(expr.left()).get());
    const auto* r = static_cast<const FloatValue*>(context_.values.at(expr.right()).get());
    push_value(std::make_unique<FloatValue>(l->value() * r->value()));
  }

  void push_value(std::unique_ptr<Value> value)
  {
    context_.values.emplace_back(std::move(value));

    context_.last_value_index = context_.values.size() - 1;
  }
};

} // namespace

auto
Interpreter::create(Runtime* runtime) -> std::unique_ptr<Interpreter>
{
  return std::make_unique<InterpreterImpl>(runtime);
}

} // namespace nabla
